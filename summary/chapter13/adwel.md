# 확장
## 확장의 네 가지 축
- 다양한 확장 유형을 적용하여 시스템을 향상 시켜야 함

### 수직 확장
- CPU 와 Memory를 높여 지연시간과 처리량을 향상 시킴
- 관계형 데이터베이스에 대한 쓰기를 신속하게 확장하기 위한 가장 적합한 선택이 될 수 있음
- 가상화로 쉽게 확장할 수 있으나 수직 확장으로 장기적인 문제 해결은 어려움

#### 구현
- 공용 클라우드 환경에서는 리소스 상향하여 쉽게 구현 가능
- 자체 환경에서는 VM조정, 필요하다면 하드웨어 구매 필요

#### 주요 이점
- 빠르고 위험 부담 없이 시도할 수 있기 때문에 확장이 필요할 때 초기에 시도해볼 가치가 있음
- 수직 확장을 통해 다른 확장 유형들을 더 쉽게 수행할 수 있음

#### 제한 사항
- CPU 클럭속도는 한계가 있어, 멀티코어로 프로그램을 작성해야 할 수 있음
- 시스템의 견고성을 개선할 수 없음
- 비용대비 성능이 항상 증가 하지 않음, 한계가 있음

### 수평 복제
- 시스템의 일부를 복제하여 작업을 분산시킴
- 비교적 단순하며 초기에 시도할 수 있음

#### 구현
- 로드밸런스를 이용하여 요청을 복제본으로 분산 시킴
- 경쟁 소비자 패턴으로 메세지 큐를 소비하여 작업을 분산
- 읽기전용 데이터 베이스를 분리하여 쓰기, 읽기 성능 모두 개선

#### 주요 이점
- 비교적 간단하며, 무중단으로 실행할 수 있음
- 부하를 분산하고 하드에워 자원에 대한 경합을 줄이는 좋은 방법

#### 제한사항
- 더 많은 인프라스트럭쳐가 필요함으로 비용 발생
- 부하를 복제본으로 분산해주는 메커니즘 구현이 필요함

### 데이터 파티셔닝
- 데이터의 일부 측면을 기반으로 부하를 분산

#### 구현
- 데이터와 관련된 키를 가져와 함수를 적용하여 저장하는 파티션을 분산
- 데이터베이스가 아닌 서비스 인스턴스 수준에서도 파티셔닝이 가능
- 대부분의 파티셔닝은 의존하는 하위 시스템에서 수행 됨

#### 주요 이점
- 트랜잭션 워크로드에 매우 유용하게 확장할 수 있음
- 유지보수 활동의 영향도와 범위를 더 쉽게 줄일 수 있음
- 수평복제와 함께 잘 작동하며, 각 파티션은 패당 작업을 처리하는 여러 노드로 구성될 수 있음

#### 제한 사항
- 시스템 견고성을 개선하는 데 한계가 있음, 따라서 수평 확장과 결합하여 견고성을 향상
- 파티션을 분산하는 기준을 잡기 어려울 수 있음
- 분산된 데이터를 하나로 모아 서비스를 처리하기 어려움
- 일반적으로 시스템의 데이터를 많이 변경해야 할 가능성이 높음

### 기능 분해
- 기능을 분리하여 새로운 마이크로서비스로 독립적 운영

#### 구현
- 마이크로서비스 구축과 동일

#### 주요 이점
- 인프라스트럭처의 리소스를 적절히 조정하여 비용을 최적화 할 수 있음
- 기능 장애를 견딜 수 있는 시스템을 구축할 기회가 생김
- 다양한 기술을 사용할 기회가 늘어남

#### 제한 사항
- 마이크로 서비스 전환은 매우 복잡한 작업
- 마이그레이션 과정에서 모든 시스템에 영향을 줄 수 있음
- 복잡성, 유지보수, 견고성 확보 등 신경써야 할 항목이 많아짐


## 결합 모델
- 하나의 유형으로 좁게 생각하지 말고 여러개를 결합 하여 확장 해야 함
- 마이크로 서비스로 전환하면 모든 확장 유형들을 쉽게 적용할 수 있음

## 작게 시작하라
- 존재하지 않는 문제를 해결하기 위해 시스템을 최적화 하는 것은 비용을 낭비하는 것
- 새로운 복잡성을 추가하면 취햑성, 관리 포인트가 늘어 날 수 있음 반드시 필요에 의해 수행해야 함

## 캐싱
- 특정 작업의 결과를 저장하고 후속 요청에서 저장된 값을 사용하여 성능을 최적화
- 너무 오래된 데이터가 사용되지 않도록 무효화 할 수 있어야 함
- 지연시간을 줄이고 애플리케이션을 확장하며, 시스템의 견고성을 개선하는데 도움 됨

### 성능을 위해
- 캐시를 사용하여 다운 스트림 호출로 발생한 네트워크 지연을 최소화 할 수 있음
- 쿼리 결과를 캐싱하여 비용이 많이 드는 데이터베이스 조회를 개선

### 캐싱 위치
- 마이크로 서비스 환경에서 캐시는 여러 위치에 저장될 수 있음

#### 클라이언트 측 캐싱
- 다운스트림 마이크로서비스에 대한 네트워크 호출을 피할 수 있기 때문에 효과적임
- 지연 시간을 개선하기 위한 캐싱 뿐만 아니라 견고성을 위한 캐싱에도 적합
- 다만 무효화 메커니즘을 적용하기 어렵고 클라이언트 사이에 데이터 불일치가 발생할 수 있음

#### 서버 측 캐싱
- 마이크로 서비스가 캐시 관리에 대한 모든 것을 책임
- 캐시 무효화 매커니즘을 구현하기 쉬움
- 데이터의 정합성을 보장할 수 있음
- 다운스트림 호출이 발생하기 때문에 지연시간을 최적화 할 수 있는 범위가 줄어듬

### 무효화
- 원본 데이터와 정합성을 유지하기 위해 캐시를 무효화 해야 함

#### TTL
- 가장 간단한 무효화 메커니즘으로 특정 기간 동안만 저장하고 무효화 함
- 구현 방법은 간단 하지만 정교성이 떨어져 원본 데이터와 다른 경우가 많이 생길 수 있음

#### 조건부 GET
- HTTP 의 ETag를 사용하여 원본 데이터가 변경 됐는지 여부를 확인 할 수 있음
- 해당 태그를 사용하여 GET요청 할 때 새로운 데이터를 내려줄 수 있음

#### 알림기반
- 알림을 받는 구독자들에게 로컬 캐시를 무효화할지 여부를 알 수 있도록 해줌
- 캐시가 오래된 데이터를 제공할 가능성을 줄어듬
- 구현이 복잡하며 알림을 보내고 처리하는 비용이 생김

#### 연속 쓰기
- 원본 데이터를 업데이트 할 때 캐시도 같이 업데이트
- 서버측에 캐시가 저장될 때 쉽게 구현할 수 있음

#### 나중 쓰기
- 캐시가 먼저 업데이트 되고 후에 원본 데이터를 업데이트, 캐시가 버퍼 역할을 수행
- 원본데이터를 업데이트 하기 전에 데이터가 손실 될 수 있음

### 캐싱의 황금 법칙
- 너무 많은 캐시를 만들면, 데이터 최신화 여부 파악과 추적을 하기 어려워 짐
- 캐싱은 복잡성을 증가시키므로 발생할 문제에 대해서 유의해야 함

### 신선도 대 최적화
- 캐싱 기간과 데이터의 정확성 중요도에 따라 균형을 맞추어 캐싱을 설계 해야 함
- 무엇을, 어디에, 어떻게 캐싱할지 미세 조정할 때는 여러 축을 따라 균형을 맞춰야 함

### 캐시 중독: 주의해야 할 이야기
- 여러 곳에 캐시를 저장할 수 있지만, 캐시가 많으면 작업이 어려워 지는 경우가 있음
- CDN 또는 사용자 브라우저와 같이 제어하기 어려운 캐시가 있다는 것을 인지해야 함

## 자동확장
- 서비스 리소스 사용량을 지속적으로 수집하여 특정 기간에 자동확장
- 트래픽이 갑자기 증가할 경우 자동 확장
- 자동 확장을 위해서는 인프라스트럭처에 여분의 리소스가 있어야 함
- 예측형, 반응형 확장은 인스턴스의 장애를 예방하는데 많은 도움을 줌

## 다시 시작하기
- 확장 임계값에 도달하여 어플리케이션을 재설계를 하는 결정은 위험할 수 있음
- 신속하게 실험하고 어떤 기능을 구축 해야하는지 정확이 파악해야 함
- 확장에 대응하기 위해 시스템을 변경해야 한다는 것은 성공의 신호