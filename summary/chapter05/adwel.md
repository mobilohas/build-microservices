# 마이크로서비스의 통신 구현
`
마이크로 서비스 통신하는 방식과 사용할 수 있는 기술을 익히며
어떤것이 적합한지, 호환성 문제는 어떻게 처리할지 고민해보자
`

## 이상적인 기술을 찾아서

### 하위 호환성을 쉽게하라
- 마이크로 서비스는 서비스간 호환성이 중요
- 변경 사항이 이전 버전과 호환되는지 검증할 수 있는 기능 필요
### 인터페이스를 명시적으로 만들라
- 마이크로 서비스에게 기대하는 기능을 사용자가 명확이 알아야 함
- 기능 설명에 대한 지원문서와 스키마를 사용해볼 것을 권장
### API를 기술 중립적으로 유지하라
- 서비스 간 통신에 사용되는 API 기술을 중립적으로 유지하는 것이 중요
- 마이크로 서비스 구현만을 위해 사용되는 기술은 피애야 함
### 소비자를 위해 서비스를 단순하게 만들라
- 마이크로 서비스를 아름답게 만드는 것 보다 쉽게 사용할 수 있도록 만들어야 함
- 서비스를 사용하는 소비자의 기술은 독립적으로 채택할 수 있어야 함
- 라이브러리를 제공하여 쉽게 사용하게 끔 유도 가능, 다만 결합이 증가
### 내부 구현 세부 사항을 숨겨라
- 내부 구현에 종속된다는 것은 결합이 증가함을 의미
- 내부 구현 변경이 소비자에게 영향을 미치게 되면 변경 비용이 증가됨

## 기술 선택

### 원격 프로시저 호출
장점
- 성능이 좋고 사용하기 쉬움
- 스키마가 있는 RPC 프레임워크를 사용하면 클라이언트 코드를 쉽게 구현
- 일반적으로 함수를 호출하나 원격에서 실행되는 구조기 때문에 다른 세부사항에 신경을 쓰지 않아도 됨

단점
- RMI처럼 특정 언어에서 사용되는 것들은 강한 기술 결합을 발생
- 로컬 함수를 호출하는 것처럼 보이지만 원격 호출로 처리 네트워크 통신이기 때문에 성능, 불확식성 같은 다양한 문제가 있을 수 있음
- 스키마가 변경되면 이를 사용하는 클라이언트에게 영향이 감

적용대상
- 마이크로 서비스간 통신에 가장 많이 사용 됨
- 데이터를 주고 받을 스키마를 정의하여 SOAP, gRPC 기술과 함께 주로 사용 

### REST

장점
- 보편적으로 HTTP 프로토콜을 사용함 HTTP는 도구와 기술을 지원하는 대규모 생태계 제공
- 리소스의 조작을 일관되게 작동하기 위해 함수 타입을 분리

단점
- HTTP를 사용함으로 TCP 통신 방식만을 사용, RPC는 UPD도 지원할 수 있음
- HATEOS 관점에서 클라이언트는 주어진 작업에 대한 정확한 엔드포인트를 찾기 위해 여러 컨트롤러를 경유해야 함
- 클라이언트에게 복잡한 명세서가 필요하며 이는 구현 비용으로 연결됨

적용 대상
- 동기식 요청 및 응답 인터페이스를 위한 확실한 선택지 (대부분의 용도에 적합)

하이퍼미디어 어플리케이션 상태의 엔진 (HATEOS)
- 클라이언트는 링크를 통해 서버와 상호작용을 할 수 있음
- 서버와의 통신을 의식하지않고 그저 링크에 접근하여 원하는 요청을 처리할 수 있음
- 서버와 클라이언트 사이의 분리가 생겨 유연성이 증가함

### 그래프QL

장점
- 동일한 정보를 검색하기 위해 여러번 요청할 필요가 없음
- 맞춤형 서버 측 집계를 구현하지 않아도 됨
- 클라이언트는 필요 정보에 대한 맞춤형 쿼리를 생성하기 때문에 비용이 최소화됨

단점
- 클라이언트에서 고비용 쿼리를 생성하여 요청한다면 서버측에 부하를 줄 수 도 있음
- HTTP 기반에서 사용하는 캐싱 설정이 어려움
- 그래프QL은 쓰기 작업에는 적합하지 않음(보안, 남용)
- 서비스가 아닌 데이터베이스를 랩핑 한 것이라고 생각할 수 있음 이는 개발 과정에서 문제로 발생

적용대상
- 외부 클라이언트에 기능을 노출하는 시스템의 경계에서 사용하는데 적합(일반적으로 GUI)
- 호출 집계 및 필터링 메커니즘으로 주로 통계에 사용

### 메세지 브로커
장점
- 비동기 통신을 구현하는데 강력한 기능을 제공
- 토픽과 큐를 사용하여 부하 분산 메커니즘 및 브로드 캐스트에 유용
- 메세지 브로커는 일반적으로 전송을 보장 해줌(클러스터 환경)

카프카
- 대규모 메세지를 처리하기 위해 설계 됨 확장에 용이
- 메세지를 소비하더라고 저장하는 기능이 있음
- 메세지를 스트림으로 처리하고 프로세싱 도구를 사용하여 다양한 작업 가능

## 직렬화 포맷

### 텍스트 포맷
- 클라이언트가 자원을 사용하는 방법이 훤씬 유연해 짐
- JSON, XML가 일반적인 텍스트 직렬화로 사용 됨

### 바이너리 포맷
- 다양한 도구 및 기술과 함꼐 높은 상호작용
- 일반적으로 gRPC에서 많이 사용
- 극도로 낮은 지연시간에서 분산 시스템을 구축해야 한다면 좋은 선택

## 스키마
- 마이크로 서비스 엔드포인트가 노출하는 것과 수용할 수 있는 것을 명시적으로 표현하는데 중요한 역할
- 개발자와 소비자에게 편리하며, 필요한 문서의 양을 줄이는데 도움 됨
- 마이크로 서비스 변경사항을 감지할 수 있음

### 구조적 계약 위반 대 의미적 계약 위반

구조적 계약 위반
- 기존 소비자와 더 이상 호환되지 않는 방식으로 스카미가 변경

의미적 계약 위반
- 기존 소비자의 기대와 다른 방식으로 요청이 처리됨을 의미

## 스키마를 사용해야 할까?
- 스키마를 사용하면 구조적 위반을 포착할 수 있음(의미적 계약 위반은 테스트로)
- 클라리언트와 서버 간 구조 계약의 일부를 명식적으로 표현하는데 도움을 줌
- 스키마가 없는 통신에서 발생할 수 있는 여러 문제를 해결하는 비용보다 스키마를 정의하는 비용이 훨씬 적음

## 마이크로서비스 간의 변경 처리

## 중단 변경 피하기
클라이언트를 중단하지 않고도 서버를 변경할 수 있어야 함

### 확장 변경
- 페이로드에 시 필드를 추가하는 것은 클라이언트에게 중대한 영향을 미치지 않음

### 관대한 독자
- 클라리언트 코드가 마이크로 서비스의 인터페이스와 너무 강하게 바인딩 되어 있지 않아야 함
- 클라이언트는 응답 받은 값 중 필요한 필요한 값만 사용

### 올바른 기술
- 인터페이스의 호환을 깨트리는 기술은 사용하면 안됨

### 명시적 인터페이스
- 명시적인 스키마를 사용하면 어떤 것을 건드리지 말아야 할지 명확하게 알게 됨

### 우발적 중단 변경을 일찍 발견하기
- 스키마 변경으로 기존 클라이언트에서 발견될 호환 문제를 먼저 판단할 수 있음
- 소지바를 중단키여야 된다는 것을 발견될시 피하거나, 같은 릴리즈를 약속

## 중단 변경 관리하기
중단 변경은 최소화 해야지만 반드시 필요해야 할 때가 생김

### 락스텝 배포
- 서버와 클라이언트 동시에 배포

### 호환되지 않는 마이크로서비스의 공존
- 호환 성을 위해 동일할 서비스의 여러 버전을 실행
- 유지 보수, 개발시 두개의 서비스를 모두 수정 배포 해야함
- 프록시 방식으로 처리해야 함으로 복잡성 증가
- 단 시간에 서비스가 공존하는 상황이면 적합
 
### 기존 인터페이스 에뮬레이션
- 동일 서비스에 기존 인터페이스 + 신규 인터페이스를 함께 제공
- 새로운 인터페이스와 마이크로 서비스를 빨리 출시할 수 있으며 소비자가 옮겨갈 시간을 확보할 수 있음
- 프록시가 아닌 어플레이션단에서 호출을 분배 함
- 개발시 호환성에 체크를 위한 유지보수가 발생

### 어던 방식을 선호하는가?
- 같은 팀이 모든 마이크로 서비스를 관리하는 상황이라면 락스텝 릴리스를 사용해도 괜찮음 하지만 익숙해지면 안됨(모놀리스로 변형될 수 있음)
- 마이크로 서비스 공존방식 보단 기존 인터페이스 에뮬레이션을 일반적으로 추천
- 두 방식다 개발 과정에서 유지보수 문제가 생기지만 후자가 문제를 더 쉽게 처리할 수 있음

### 사회적 계약
- 기존 인터페이스를 계속 사용하는데에 비용이 발생할 수 있으므로 가능한 빠르게 전환하는 것이 이상적
- 하지만 소비자에게 변경을 수행할 시간을 최대한 많이 줘야 함
- 서비스 제공자와 소비자의 요구가 균형을 이루도록 조정해야 함
- 소비자를 변경 못할 수 있는 환경도 있음, 오래된 인터페이스 지원 vs 소비자로 부터 얻는 수익을 잘 비교해야 함

### 사용성 추적
- 소비자가 더 이상 오래된 인터페이스를 사용하지 않는 시점을 추적할 수 있어야 함
- 오래된 인터페이스를 계속 사용하는 팀을 식별하여 이야기 해야 함
- 만약 소비자가 새로운 인터페이스로의 변경을 주저하고 있다면 도움을 줘야 함

### 극단적 조치
- 기존 인터페이스를 계기하는 기간을 정하고 기간이 만료되면 해당 인터페이스를 폐기
- 인터페이스를 폐기해도 사용하고 있는 소비자를 추적할 수 있어야 함
- 기존 인터페이스를 일부러 느리게 만들어 변경을 유도 할 수 있음

## 마이크로서비스 세계에서 DRY와 코드 재사용의 위험
- 동일한 코드가 많으면 유지 보수시 버그로 이어질 수 있음

### 라이브러리를 통한 코드 공유
- 공유 코드가 서비스 경계 외부로 새어나가 사용되면 잠재적인 형태의 결합이 생김
- 라이브러리를 한번에 업데이트 할 수 없다는 것을 인지해야 함
- 서비스를 사용하게 하는 클라이언트 라이브러리를 제공한다면 코드 중복을 피할 수 있음
- 하지만 클라이언트 라이브러리 개발은 비용 발생 및 기술 선택에도 제한이 있음
- 시간에 지남에 따라 클라이언트와 서버간에 결합이 이루어 질 수 있음 이는 다른 서비스와의 결합을 의미


## 서비스 디스커버리
여러개의 마이크로 서비스를 운영 할 떄 각각의 서비스를 식별하고 모니터링 할 수 있어야 함
### DNS
- 마이크로 서비스에 DNS을 할당하여 서비스를 식별, 추적 가능
- 모든 기술 스택이 지원하고 널리 사용되는 표준임

### 동적 서비스 레지스트리
중앙 레지스트리에서 등록된 마이크로 서비스를 조회하는 다양한 기술이 있음

주키퍼
- 최소 3개의 노드로 구성되어 고가용성을 보장 함
- 네임스페이스를 제공, 새로운 노드 삽입 변경시 감시할 수 있음

콘술
- 서비스 디스커버리를 위한 HTTP 인터페이스를 제공
- 서비스 등록에서 키/값 저장소 쿼리나 상태 확인 추가 등 다양한 HTTP 인터페이스 제공
- 텍스트 파일(콘술 템플릿)을 사용해 시스템의 구성파일을 동적으로 업데이트 할 수 있음

etcd와 쿠버네티스
- 파드에 메타 데이터를 부여, 해당 메타데이터와 정의된 패턴을 패칭하여 서비스를 식별
- 콘술, 주키퍼가 제공하는 대표적인 기능들을 포함하고 있음

내식대로 만들기
- 인스턴스의 태그를 정의하여 식별 추적할 수 있는 기능을 직접 제작
- 현재는 관련 기술이 많아 할 필요가 없음

## 서비스 메시와 API 게이트 
- 마이크로서비스 호출을 프록시로 동작하게 도와줌
- 서비스 메시는 클러스 내부(동-서 방향)에서 게이트웨이는 외,내부(남-북 방향) 통신을 처리

### API 게이트 웨이
주로 HTTP 프록시 기반, 리버스 프록시로 동작

적용 대상
- 일반적으로 외, 내부 통신만을 위한 기능만 사용
- 통신이 아닌 다른 기능들은 오히려 불필요 할 때가 많음

회피대상 
- 게이트웨이의 역할을 어디까지 가져갈지 고민하고 신중히 사용 해야함
- 게이트 웨이가 어플리케이션 코드에 영향을 미쳐서는 안됨
- 또 모든 서비스에 적용시 네트워크 호출 병목이 발생할 수 있음

### 서비스 메시
- 서비스 코드 영역과 네트워크 영역으로 관심사를 분리하여 구현 가능
- 서비스간 공통기능을 재 사용할 수 있고 표준 동작을 구현하는데 용이
- 요청 타임아웃과 같은 범용적인 요구 사항을 구성
- 프록시 간 호출로 인한 영향을 제한 하는데 사용

작동 방식
- 마이크로 서비스와 동일한 네이퉈크 환경에서 실행 됨(버추얼 머신, 파드)
- 서비스 메시는 컨트롤 플레인에서 관리

필요성
- 쿠버네티스를 사용하지 않으면 사용하기 어려움
- 복잡성이 가중됨
- 서로 다른 언어로 구성된 마이크로 서비스라면 고려해 볼 수 있음

### 다른 프로토콜은?
- HTTP 기반이 아닌(ex 카프카) 프로토콜이라면 게이트웨이 및 서비스 메시를 사용하기 어려움
- 이는 서비스 간의 모든 호출에 대한 중개자 역할 두 기능이 할 수 없음을 의미

## 서비스 문서화
- 각각의 서비스 엔드 포인트에 대한 문서 필요

### 명시적 스키마
- 명시적 스키마는 엔드포인트의 사용 방법 이해를 도와줌
- 명시적 스키마가 없다면 문서화가 어려워 짐

### 자기 기술 시스템
- 서비스 목록, 상태 등을 내부적으로 관리하는 것이 좋음
- 서비스를 대규모로 확장할 때 발생할 수 있는 새로운 복잡성을 관리할 때 도움이 될것임