# 배포
`
마이크로 서비스의 다양한 배포 방식을 알아보고
해당 방식을 지원하는 대표적인 기술을 알아보기
`

## 논리적에서 물리적으로

### 다수 인스턴스
- 일반적으로 더 많은 부하처리, 시스템 견고성 향상을 위해 다수의 인스턴스를 사용
- 다수의 인스턴스는 서로 다른 물리 데이터 센터에 분산되어 있는게 안전함

### 데이터 베이스
- 동일한 마이크로 서비스는 같은 데이터 베이스를 공유하는게 적합

#### 데이터 배포 및 확장
- 트래픽을 분산하기 위해 읽기 전용 데이터베이스를 분리
- 하나의 물리 데이터베이스에 논리적으로 분리하여 사용하면 관리 비용이 적어짐
- 하지만 물리 머신까지 분리시 각각 서비스의 의존하지 않고 더많은 제어가 가능

### 환경
- 어플리케이션을 개발하고 배포하는 과정은 환경에 따라 크게 좌우 될 수 있음
- 개발 - 테스트 - 사전운영 - 운영 환경이 모두 정확한 복사본이 된다면 가장 이상적 하지만 마이크로 서비스환경에서는 매우 어려움
- 마이크로 서비스는 여러 환경에 배포될 수 있으며, 다른 환경으로 넘어갈 때 인스턴스 수는 요구 사항에 달라질 수 있음

## 마이크로서비스 배포 원칙

### 격리 실행
- 마이크로 서비스는 모니터링, 장애영향, 패키지 의존성 때문에 각각의 호스트에서 실행하는게 적합
- 컨테이너화 기술이 발전되면서 격리된 실행 환경을 보장하기 쉬어짐

### 자동화 집중
- 마이크로서비스 환경은 관리 포인트, 복잡성이 높으므로 자동화에 집중해야함
- 자동화는 사전 작업으로 인한 부하가 발생할 수 있으나, 후에 훨씬 더 효율적으로 일이 가능

### 코드형 인프라스트럭처
- 코드형 인프라스트럭처는 소프트웨어 개발 개념을 운영 영역으로 가져옴
- 코드의 버전을 제어함으로 변경사항에 대한 추적, 투명성을 확보할 수 있고 특정 환경을 재현 하는게 쉬어짐

### 무중단 배포
- 무중단 배포는 업스트림 소비자에게 영향을 주지 않아 마이크로 서비스 환경에 적합
- 비동기 (메세지 큐) 방식이면 메세지가 유실되지않아 비교적 쉽게 구현할 수 있음
- 롤링 업데이트 개념을 사용하여 적용할 수 잇음

### 기대 상태 관리
- 마이크로 서비스에 필요한 자원,인스턴스를 지정하고 해당 상태를 유지 할수 있도록 해야 함
- 관리자는 상태를 정의하는데만 집중하고, 상태유지는 자동으로 처리되어야 함 

#### 전제 조건
- 플랫폼에서 마이크로 서비스를 자동으로 시작하는 방법이 필요
- 인스턴스가 교체 되는 과정에서 부하를 처리하는 여분의 리소스가 필요

#### 깃옵스
- 기대 상태를 코드로 정의하고 소스 제어 툴을 사용하여 인프라를 관리
- 깃옵스 도구로 코드형 인프라스트럭쳐 개념을 도입하여 기대상태,운영환경 관리의 효율성을 높일 수 있음

### 배포 방법
### 물리머신
- 물리 머신에 직접 배포하면 리소스 활용도가 낮아 질 수 있음
- 가상화나 컨테이너가 제공하고 있는 유연성이 높기 때문에 사용되지 않음
### 가상머신
- 마이크로 서비스를 격리된 실행환경으로 하나의 물리머신에 실행할 수 있음
- 컴퓨터 리소스 측면에서 효율 적이지 않음 오버헤드 발생
- 컨테이너보다 더 엄격한 격리 수준이 필요하거나 컨테이너화가 어려울 경우 적합

### 컨테이너
- 하이퍼바이저 없이 하부 머신의 커널을 사용하여 가상화 하기 때문에 자원을 절약할 수 있음
- 프로지버닝이 가상머신에 비해 매우 빠름
- 컨테이너 외부 호스팅을 위한 적절한 네트워크 인터페이스가 필요

#### 윈도우 컨테이너
- 윈도우 Hyper-V는 컨테이너를 프로세스 격리, 커널 격리로 지정하여 사용할 수 있음

#### 도커
- 도커는 컨테이너를 이미지로 추상화하여 네트워크 인터페이스, 레지스트리 개념을 제공
- 도커 데스크탑을 활용하여 로컬에서도 쉽게 가상화 가능

### 어플리케이션 컨테이너
- 하나의 컨테이너 여러 서비스 및 어플리케이션을 같이 사용하는 것은 신중해야 함
- 각각의 어플리케이션 수명주기 관리, 서비스 확장에 어려움이 생김

### Paas
- 호스트보다 더 고수준의 추상화에서 작업, 어플리케이션을 자동으로 프로비저닝하고 실행
- 내부에 접근할 수 있는 권한이 제한 되기 때문에 문제 해결이 어려움

### FASS
- Paas 에서 더 발전된 형태 어플리케이션이 아닌 실행 가능한 함수로 로직 실행
- 사용되는 만큼 비용을 지불

#### 제한 사항
- 주로 컨테이너 기술을 사용하고 캡슐화 되어있어 제어 부족
- 함수에 대한 리소스를 미세 조정 하기 어려움
- 기술에 맞는 언어를 제공해줄 FAAS 업체가 필요

#### 문제점
- 시작시간 (Cold Start, Warm Up) 문제를 해결해야 함
- 동적 확장 시 다른 인프라스트럭처에 문제가 발생할 수 있음

#### 마이크로서비스와 매핑
- 마이크로 서비스당 함수 매핑 - 마이크로 서비스를 함수 하나에 매핑 인바운드 요청 경로에 따라 처리
- 애그리거트당 함수 매핑  - 애그리거트 단위로 더 작은 단위로 매핑 
- 마이크로서비스는 독립적으로 배포 가능한 단위로 해당 정의를 고려하여 세분화 해야 함 

### 어떤 배포가 적합할까?
- 현재 환경에서 적합한 기술을 사용해야함 반드시 쿠버네티스가 아니여도 됨
- PAAS가 적합하다면 PAAS로, 쿠버네티스를 고려하고 있다면 FAAS를 먼저 사용해봐도 좋음

## 쿠버네티스와 컨테이너 오케스트레이션
### 컨테이너 오케스트레이션에 대한 사례
- 정의한 기대상태를 유지하는데 도움을 줌
- 같은 마이크로 서비스를 서로 다른 노드에서 실행시킬 수 있게 스케줄링
### 쿠버네티스의 개념 엿보기
- 컨테이너로 구성된 파드는 컨트롤 플레인을 통해 워커노드에서 실행됨
- 서비스를 통하여 엔드포인트를 정의, 네트워크 인터페이스와 매핑됨
- 레플리카셋으로 파드의 기대상태를 정의

### 멀티테넌시와 페데레이션
- 하나의 클러스터를 여러 팀이 공유할 시 서로 다른 수준의 제어가 필요
- 멀티테넌시를 제공해주는 플랫폼 혹은 페데레이션 모델을 적용할 수 있음
- 멀티 클러스터 환경이라면 클러스터 업그레이드시 더 안전하고 쉬움

### 클라우드 네이티브 컴퓨팅 재단
- 오픈 소스의 표준 및 상호 윤용성을 제공하는데 기여
- 쿠버네티스 성공에 큰 역할을 기여

### 플랫폼과 이식성
- 쿠버네티스 클러스터는 사용되는 오픈 소스 및 기술(메세지큐, 모니터링)을 패키징하여 자체 플랫폼으로 진화됨
- 클러스트터를 이동할 경우 플랫폼을 다시 구성해야 하기 때문에 간단하지 않음

### 헬름, 오퍼레티어, CRD
- 쿠버네티스 내에서 사용되고 있는 미들웨어를 관리 할 수 있게 도와줌
- CRD를 정의하여 쿠버네티스 API를 확장, 유연하게 클러스터 내의 파드를 관리 할 수 있음

### Knative
- 쿠버네티스 복잡성을 숨기고 FAAS를 지원할 수 있게 도와줌

### 미래
- 쿠버네티스는 앞으로 더 많은 추상화를 제공할 것으로 예상

### 사용해야 할까?
- 쿠버네티스 클러스터를 구현하는것은 매우 어려움 클라우드에서 제공하는 클러스터를 먼저 사용할 것을 추천
- 기술의 유행보다는 필요성에 의해 사용해야 함

## 점진적 제공
- 자주 배포하고 변경 실패율도 낮으면 더 좋은 성과를 가져다움
- 토글, 카나리아 릴리스, 병렬 실행을 통해 점진적 제공

### 배포와 릴리스 분리
- 배포는 운영환경에 적용, 실제 사용자가 사용한다면 릴리즈
- 블루그린 배포에서 블루는 배포 그린은 릴리즈의 개념

### 점진적 제공으로
- 블루그린 배포가 점진적 제공 기술 중 하나
- 결과에 밀접한 책임이 있는 프로젝트 오너에게 기능 제어를 위함

### 기능 토글
- 지정된 시간에 기능으 켜거나 문제가 되는 경우 끄는데 유용
- 사용자에 특성에 따라 플래그를 지정하여 다른 기능을 제공

### 카나리아 릴리스
- 일부 사용자에게만 새로운 기능을 제공, 문제 발생 시 해당 사용자만 영향
- 마이크로 서비스 수준에서는 토글을 외부 네트워킹/라우팅에서 제어
- 롤아웃을 제어하여 비율을 점진적으로 증가, 제어를 자동으로 도와주는 툴도 있음

### 병렬 실행
- 새 기능과 이전 버전의 기능을 비교하려면 병렬 실행이 필요
