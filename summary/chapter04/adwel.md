# 마이크로 서비스 통신 방식
`
마이크로 서비스간의 통신을 하는 다양한 방법을 알아보자
`

##  프로세스 내부에서 프로세스 사이로
- 프로세스 내부 호출과 프로세스 사이의 호출의 다른 점

### 성능
- 내부 호출과 패킷을 통한 호출 방식은 성능에서 많은 차이가 발생
- 프로세스 내에서는 적합한 API가 프로세스 사이에서는 적합하지 않을 경우가 많음
- 지연시간 뿐만 아니라 어플리케이션이 사용하는 메모리, 네트워크 리소스도 고려

### 인터페이스 변경
- 프로세스 내에서 인터페이스 변경은 어렵지 않은 작업
- 프로세스 통신간에 사용하고 있는 인터페이스를 변경한다면 배포를 같이 해야 함

### 에러 처리
- 프로세스 내에서 에러를 처리하는기능이 매우 직관적이며 유동적임
- 분산 프로세스에서는 네트워크 통신, 프로세스 과부화, 물리적인 인프라 문제 등등 더 많은 에러처리가 필요

### 실패 모드
- 충돌실패 - 서버에 크래쉬가 발생
- 누락 실패 - 전송 후 응답을 받지 못함
- 타이밍 실패 - 응답을 제 시간에 받지 못함
- 응답 실패 - 응답은 받았지만 잘못된 응답을 받음
- 임의 실패(비잔티움 실패) - 프로세스 사이에서 발생한 경합 문제로 실패

이러한 문제는 일시적인 경우가 많지만 쉽게 처리 할 수 없기 때문에 사람의 개입이 필요 할 수 있음  
에러에 대한 더 풍부한 의미 쳬게를 갖춰야 함 (http가 좋은 예)


### 프로세스 간 통신을 위한 기술: 다양한 선택
- 서비스간 통신은 다양한 기술로 구현 할 수 있음
- 기술을 채택할 때는 익숙한 기술, 최신 기술을 기준보다는 구현하는데 적합한 기술을 찾아야 함


## 마이크로서비스 통신 방식
- 요청 및 응답 과 이벤트 기반 중 어떤 통신방식이 서비스에 적합한지 살펴봐야 함
- 요청 및 응답이 적합할 경우 동기와 비동기중 선택가능 이벤트 기반은 비동기로 제한 됨
- 통신 방식 외에도 지연시간, 보안, 확장 등 다른 사항도 고려해야 함
- 마이크로 서비스에서는 다양한 통신 방식이 혼재될 수 있으며, 이것은 지극히 일반적임

## 동기식 블로킹
- 서비스를 호출하고 응답을 기다리는 방식
- 일반적으로 호출 결과에 따라 연산을 처리해야 할 경우 사용

### 장점
- 동기식 방식은 직관적이고 익숙함
- 익숙하기 때문에 마이크로 서비스 전환 시 합리적인 선택이 될 수 있음

### 단점
- 결합이 발생, 다른 서비스 요청 응답에서 문제 발생 시 각각의 처리가 필요
- 응답이 손실 될 수 있다는 것을 생각 해야 함
- 서비스간 호출에서 지연 이슈가 있다면 연속적으로 발생 (시간적 결합)
- 연쇄적인 문제에 취약해짐, 호출 체인이 많아질 떄 문제가 더 발생

시간적 결합은 서비스가 어떤 작업을 수행할 때 다른 마이크로 서비스가 필요함을 의미  
잠재적인 리소스 경합 문제 발생

### 적용대상
- 일반적으로 사용하는데 큰 문제가 없고, 익숙하기 때문에 유리함
- 다만 호출체인이 많다면 서비스간의 상호작용을 재 검토 해야함
- 호출체인을 줄여 전반적인 지연 시간 개선 필요, 또 서비스에 중요한 하지 않는 작업을 분리
- 관점지향으로 변경할 수 있는 부분을 찾아야함


## 비동기식 논블로킹
- 호출에 대한 응답 기다리지 않고 처리를 계속 할 수 있어야 함  
- 마이크로 서비스에서 가장 일반적으로 사용하는 세가지 논블로킹 방식

- 공통 데이터를 통한 통신
    - 공통 데이터를 변경하고 다른 마이크로 서비스에서 해당 데이터를 사용 함

- 요청 및 응답
    - 다른 마이크로 서비스에게 요청을 보내가 응답을 수신함

- 이벤트 기반 상호작용
    - 브로드 캐스트 방식으로 이벤트를 발행, 다른 마이크로 서비스는 수신하여 처리

### 장점
- 시간적 결합이 발생 하지 않음 
- 기능을 처리하는 데 오랜 시간이 걸리는 경우에 유용함

### 단점
- 서비스를 구현하는 방법이 복잡함
- 일반 적으로 익숙하지 않기 때문에 구현 난이도가 있음
- 데이터를 동기화 하기 어려움

### 적용 대상
- 서비스를 처리가 상대 적으로 오래 걸리는 프로세스에 적합
- 호출 체인이 복잡한 프로세스에 적합


## 공통 데이터를 통한 통신
- 공유 데이터를 저장하고 다른 마이크로 서비스가 그 데이터를 사용
- 기본적으로 비동기식으로 작동 됨

### 구현
- 일반적으로 파일 시스템을 사용 함
- 다른 마이크로 서비스는 폴링으로 데이터를 확인
- 데이터 레이크와 데이터 웨어하우스는 정보의 흐름을 한 방향으로 가정하기 때문에
데이터를 쉽게 추론할 수 있음 때문에 적합함

### 장점
- 매우 간단하게 구현 가능
- 다양한 유형의 시스템들과 상호 운용할 수 있다
- 데이터가 많다고 해서 문제가 발생하지 않음

### 단점
- 폴링 방식으로 작동하기 때문에 실시간 처리 부족
- 이벤트 방식으로 해결 할 수 있지만 그건 다른 기술이 더 적합
- 공통 결합이 발생, 때문에 문제가 발생 할 수 있음
- 파일 시스템이 견고성에 따라 통신의 견고성이 결정 됨 (데이터 저장소가 안전해야 함)

### 적용 대상
- 기술 제약이 있는 프로세스 사이에서 상호 윤용성을 활성화 할 때 적합
- 구형 시스템은 새로운 기술 적용에 대한 제한이 있으며 비용이 많이듬 하지만 파일 읽기, 쓰기는 구형 시스템에서도 쉽게 사용 가능
- 대용량 데이터를 공유할 때도 큰 장점 (대용량 데이터 전송은 부담이 있기마련)

## 요청 및 응답 통신
- 동기, 비동기 모두 구현 가능한 패턴
- 특정 순서로 호출을 완료 해야하는 상황에서 사용하는 것이 일반적

### 구현: 동기 대 비동기
- 동기는 요청을 한 서비스에 대해 모르지만 비동기는 콜백을 해야 함으로 알고 있어야 함
- 비동기 방식이 동기보다 조금 더 복잡함
- 비동기 방식은 연쇄적인 장애발생 시 좀 더 이점이 있음 또 성능적으로 유리
- 두 방식 모두응답이 오지 않을 것을 대비하여 타임아웃 구현 해야함

### 적용대상
- 프로세스를 처리하는 과정에서 요청 결과를 확인해야 하는 모든 상황에 적합
- 재시도와 같은 일종의 보상 조치가 필요한 서비스에 적합

## 이벤트 기반
- 다른 서비스에 작접을 요청 하지만 수신 여부가 보장되지 않음
- 일반 적으로 비동기식 상호작용
- 이벤트 발행자는 수신자가 누군지 모름 따라서 느슨하게 결합 됨
- 수신자는 발행된 이벤트에 대해 이해하고 있어야 하기 때문에 높은 수준의 도메인 결합이 이루어짐

### 구현
- 메세지 큐를 이용하면 느슨한 결합으로 아키텍처를 구현하는데 효과 적임
- HTTP로 구현 가능하지만 지연 시간 측면에서는 좋지 않음
- 메세지큐는 경쟁 소비자 패턴에서 더 나은 환경을 제공

### 이벤트에 포함 되는 것
이벤트를 발행할 때 담아야할 데이터
- ID 만
    - 데이터의 고유 번호를 전달
    - 이벤트 수신자는 ID로 데이터를 조회 해야 함으로 결합 발생
    - 서비스가 커질 수록 문제가 발생 할 수 있음
- 모든 데이터
    - 모든 데이터를 담아서 전달
    - 더 많은 정보가 서비스를 느슨하게 결합 해줌
    - 보안 문제가 발생 할 수 있음

### 적용대상
- 느슨한 결합에 중점을 두는 상황이라면 매우 적합
- 협업 방식에 대한 노출이 제한적일 때는 더 복잡할 수 있음

## 조심해서 진행하라
비동기 방식은 구현 복잡성을 증가 시킴
적절한 모니터링, 프로세스 경계를 거쳐 요청을 추적해주는 환경이 필요